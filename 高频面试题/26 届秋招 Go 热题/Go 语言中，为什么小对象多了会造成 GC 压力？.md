## Go 语言中，为什么小对象多了会造成 GC 压力？
> 八股文一网打尽，更多面试题请看[程序员面试刷题神器 - 面试鸭](https://www.mianshiya.com/)

## 回答重点

因为对象越多，垃圾回收器需要管理的对象数量也就越多，这会增加垃圾回收器的工作量，GC 需要跟踪每个分配的对象，并在对象不可达时回收它们的内存。

且与大对象相比，小对象通常是短命的，会频繁地被分配和释放，会导致更多的内存碎片和更高的内存管理开销，从而增加 GC 的压力。


## 扩展知识

### 小对象对GC的影响

1）分配频率高：小对象通常是短命的，会频繁地被分配和释放。GC需要跟踪每个分配的对象，并在对象不可达时回收它们的内存；且频繁的小对象分配和释放会造成内存碎片，使得堆内存的管理和分配效率降低，增加了GC的工作量。

2）标记开销大：每个小对象都需要被标记为可达或不可达。随着小对象数量的增加，GC需要标记的对象数量也增加，导致标记阶段的开销变大；且GC需要遍历所有对象的指针来确定哪些对象是可达的。大量的小对象意味着更多的指针遍历操作。

3）清除阶段压力大：在清除阶段，GC需要检查并清理所有未标记的小对象。这会增加清除阶段的工作量和时间；且大量的小对象释放操作会增加内存回收的频率和成本。

### Go的垃圾回收机制

Go语言的垃圾回收器使用的是一种三色标记-清除算法。这个算法大致分为以下几个步骤：

标记：从根对象开始，标记所有可达对象。

清除：清除所有未标记的对象，释放它们占用的内存。

并发：Go的GC是并发的，意味着GC在程序运行时并行工作，以减少程序的停顿时间。



### 小对象的典型场景

1）短临时字符串：在字符串操作中频繁创建和销毁短字符串。

```go
func process(data []byte) {
    str := string(data) // 创建短临时字符串
    // 使用 str
}
```

2）小结构体：频繁创建和销毁小结构体或**包含指针**的小对象。

```go
type SmallStruct struct {
    A int
    B *int
}

func process() {
    s := SmallStruct{A: 1, B: new(int)} // 创建小结构体
    // 使用 s
}
```

3）临时缓冲区：短时间内频繁分配和释放的临时缓冲区对象。

```go
func processData(data []byte) {
    buf := make([]byte, 1024) // 创建临时缓冲区
    copy(buf, data)
    // 使用 buf
}
```


> 八股文一网打尽，更多面试题请看[程序员面试刷题神器 - 面试鸭](https://www.mianshiya.com/)
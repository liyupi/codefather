## Go 语言中逃逸分析是怎么进行的？
> 八股文一网打尽，更多面试题请看[程序员面试刷题神器 - 面试鸭](https://www.mianshiya.com/)

## 回答重点

逃逸分析是编译器优化的一部分，用来决定对象应该分配在栈上还是堆上。

在 Go 语言中，**编译器会在编译期间进行逃逸分析**，通过分析代码中的变量确定它们是否会 “逃逸” 出当前的作用域。

如果一个变量在函数或方法内被创建，但在函数外部仍然被引用，那么它将被称为 “逃逸”，需要分配到堆上；否则，它将被分配在栈上。

**栈分配和堆分配的区别**：
- 栈分配的好处是分配和释放内存的开销非常小，速度快。
- 堆分配需要依赖垃圾回收器（GC）来管理内存，因此开销相对较大。

## 扩展知识

### 逃逸分析的过程

逃逸分析由编译器在编译期间进行，它检查每一个变量的使用情况。编译器根据变量的作用范围、生命周期、以及变量是否被传递给其他协程或返回到外部等来确定其是否逃逸。

主要的原则包括：
- 若变量的生命周期超出当前函数，则视为逃逸。
- 若变量被引用并存储到堆上，则视为逃逸。
- 若变量被传递给外部函数、方法或 goroutine，且存活时间可能超过当前函数，则视为逃逸。

**具体示例**：

假设有如下 Go 代码：
```go
package main

import "fmt"

func escapeExample() *int {
    x := 42       // 局部变量 x
    return &x     // 返回 x 的地址，x 发生逃逸，分配到堆上
}

func stackExample() int {
    x := 42       // 局部变量 x
    return x      // x 没有逃逸，分配在栈上
}
```

**编译器会在编译期间识别并优化这种情况。**

### 查看逃逸分析结果

可以使用 `go build` 命令的 `-gcflags` 参数来查看编译器的逃逸分析结果。

```shell
$ go build -gcflags=-m main.go
```
输出类似如下信息：
```shell
./main.go:6:2: moved to heap: x
./main.go:11:2: x does not escape
```

- `moved to heap` 表示变量 x 逃逸到了堆上。
- `does not escape` 表示变量 x 分配在栈上。

### 逃逸分析的优化技巧

返回指针、闭包捕获、接口赋值、动态类型转换等会导致变量逃逸。

1. 避免不必要的指针返回：如果可能，返回值而不是返回指针。
2. 减少闭包对变量的引用：避免在闭包中使用外部变量，尽量将变量传递给闭包。
3. 避免接口赋值：使用具体类型代替接口，减少逃逸到堆的可能性。




> 八股文一网打尽，更多面试题请看[程序员面试刷题神器 - 面试鸭](https://www.mianshiya.com/)